# Terraform Deployment Workflow
name: Terraform Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: '1.5.0'
  AWS_REGION: 'us-east-1'

jobs:
  terraform:
    name: Terraform ${{ github.event.inputs.action }}
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    defaults:
      run:
        working-directory: ./terraform
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
    
    - name: Setup Terraform Backend
      run: |
        # Get AWS Account ID
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_ENV
        
        # Create S3 bucket for Terraform state if it doesn't exist
        BUCKET_NAME="ai-recipes-terraform-state-${ACCOUNT_ID}"
        if ! aws s3 ls "s3://${BUCKET_NAME}" 2>/dev/null; then
          echo "Creating S3 bucket: ${BUCKET_NAME}"
          aws s3 mb "s3://${BUCKET_NAME}"
          aws s3api put-bucket-versioning --bucket "${BUCKET_NAME}" --versioning-configuration Status=Enabled
          aws s3api put-bucket-encryption --bucket "${BUCKET_NAME}" --server-side-encryption-configuration '{
            "Rules": [
              {
                "ApplyServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }
            ]
          }'
        fi
        
        # Create DynamoDB table for state locking if it doesn't exist
        TABLE_NAME="ai-recipes-terraform-locks"
        if ! aws dynamodb describe-table --table-name "${TABLE_NAME}" 2>/dev/null; then
          echo "Creating DynamoDB table: ${TABLE_NAME}"
          aws dynamodb create-table \
            --table-name "${TABLE_NAME}" \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5
          aws dynamodb wait table-exists --table-name "${TABLE_NAME}"
        fi
        
        # Update backend configuration
        sed -i "s/bucket = \".*\"/bucket = \"${BUCKET_NAME}\"/" main.tf
        sed -i "s/dynamodb_table = \".*\"/dynamodb_table = \"${TABLE_NAME}\"/" main.tf
    
    - name: Terraform Init
      run: terraform init
    
    - name: Terraform Validate
      run: terraform validate
    
    - name: Terraform Format Check
      run: terraform fmt -check
    
    - name: Terraform Plan
      if: github.event.inputs.action == 'plan' || github.event.inputs.action == 'apply'
      run: |
        terraform plan \
          -var-file="environments/${{ github.event.inputs.environment }}.tfvars" \
          -var="gemini_api_key=${{ secrets.GEMINI_API_KEY }}" \
          -out=${{ github.event.inputs.environment }}.tfplan
      env:
        TF_VAR_gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
    
    - name: Terraform Apply
      if: github.event.inputs.action == 'apply'
      run: |
        terraform apply -auto-approve ${{ github.event.inputs.environment }}.tfplan
      env:
        TF_VAR_gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
    
    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: |
        terraform destroy -auto-approve \
          -var-file="environments/${{ github.event.inputs.environment }}.tfvars" \
          -var="gemini_api_key=${{ secrets.GEMINI_API_KEY }}"
      env:
        TF_VAR_gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
    
    - name: Get Terraform Outputs
      if: github.event.inputs.action == 'apply'
      run: |
        echo "## Terraform Outputs" >> $GITHUB_STEP_SUMMARY
        echo "### Environment: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if terraform output frontend_url &> /dev/null; then
          echo "- **Frontend URL**: $(terraform output -raw frontend_url)" >> $GITHUB_STEP_SUMMARY
        fi
        
        if terraform output api_url &> /dev/null; then
          echo "- **API URL**: $(terraform output -raw api_url)" >> $GITHUB_STEP_SUMMARY
        fi
        
        if terraform output ecr_repository_url &> /dev/null; then
          echo "- **ECR Repository**: $(terraform output -raw ecr_repository_url)" >> $GITHUB_STEP_SUMMARY
        fi
        
        if terraform output database_endpoint &> /dev/null; then
          echo "- **Database Endpoint**: $(terraform output -raw database_endpoint)" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Upload Terraform Plan
      if: github.event.inputs.action == 'plan'
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ github.event.inputs.environment }}
        path: terraform/${{ github.event.inputs.environment }}.tfplan
        retention-days: 30

  deploy-application:
    name: Deploy Application
    needs: terraform
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'apply'
    environment: ${{ github.event.inputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
    
    - name: Initialize Terraform for Outputs
      working-directory: ./terraform
      run: |
        # Setup backend configuration
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        BUCKET_NAME="ai-recipes-terraform-state-${ACCOUNT_ID}"
        TABLE_NAME="ai-recipes-terraform-locks"
        
        sed -i "s/bucket = \".*\"/bucket = \"${BUCKET_NAME}\"/" main.tf
        sed -i "s/dynamodb_table = \".*\"/dynamodb_table = \"${TABLE_NAME}\"/" main.tf
        
        terraform init
    
    - name: Get Infrastructure Outputs
      working-directory: ./terraform
      run: |
        ECR_REPO=$(terraform output -raw ecr_repository_url)
        BUCKET_NAME=$(terraform output -raw frontend_bucket_name)
        DISTRIBUTION_ID=$(terraform output -raw cloudfront_distribution_id)
        
        echo "ECR_REPO=$ECR_REPO" >> $GITHUB_ENV
        echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV
        echo "DISTRIBUTION_ID=$DISTRIBUTION_ID" >> $GITHUB_ENV
    
    - name: Build and Push Docker Image
      run: |
        # Login to ECR
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_REPO
        
        # Build image
        docker build -t ai-recipes-generator-backend ./backend
        
        # Tag image
        docker tag ai-recipes-generator-backend:latest $ECR_REPO:latest
        docker tag ai-recipes-generator-backend:latest $ECR_REPO:${{ github.sha }}
        
        # Push image
        docker push $ECR_REPO:latest
        docker push $ECR_REPO:${{ github.sha }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Build and Deploy Frontend
      run: |
        cd frontend
        npm ci
        npm run build
        
        # Upload to S3
        aws s3 sync build/ s3://$BUCKET_NAME --delete
        
        # Invalidate CloudFront cache
        aws cloudfront create-invalidation --distribution-id $DISTRIBUTION_ID --paths "/*"
    
    - name: Force ECS Service Update
      run: |
        # Get ECS cluster and service names
        cd terraform
        CLUSTER_NAME=$(terraform output -raw ecs_cluster_name)
        SERVICE_NAME=$(terraform output -raw backend_service_name)
        
        # Force service update to pull new image
        aws ecs update-service \
          --cluster $CLUSTER_NAME \
          --service $SERVICE_NAME \
          --force-new-deployment
    
    - name: Wait for ECS Service Stability
      run: |
        cd terraform
        CLUSTER_NAME=$(terraform output -raw ecs_cluster_name)
        SERVICE_NAME=$(terraform output -raw backend_service_name)
        
        echo "Waiting for ECS service to stabilize..."
        aws ecs wait services-stable \
          --cluster $CLUSTER_NAME \
          --services $SERVICE_NAME
    
    - name: Deployment Summary
      run: |
        cd terraform
        
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "### Environment: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "### Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if terraform output frontend_url &> /dev/null; then
          FRONTEND_URL=$(terraform output -raw frontend_url)
          echo "- **Frontend URL**: [$FRONTEND_URL]($FRONTEND_URL)" >> $GITHUB_STEP_SUMMARY
        fi
        
        if terraform output api_url &> /dev/null; then
          API_URL=$(terraform output -raw api_url)
          echo "- **API URL**: [$API_URL]($API_URL)" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "- **Docker Image**: $ECR_REPO:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployment Time**: $(date)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… Deployment completed successfully!" >> $GITHUB_STEP_SUMMARY
